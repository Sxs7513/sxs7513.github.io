---
title: hexo-serverless 腾讯云部署原理分析(2)
date: 2020-06-22 16:22:49
---

在 {% post_link hexo-serverless 腾讯云部署原理分析(1) %} 文中描述的是 serverless component 的部署原理，本文阐述的是 serverless plugin 的工作原理，下面用简单的篇幅来说明这两者的区别。

## 什么是 Serverless Component

- 相同之处。这两者均是部署云函数的不同方案
- 不同之处
  - Component 是云产品的工具，云产品可以理解为高级的云函数。通过配置 Yaml 可以组合使用 Component，比如使用 tencent-cos 部署 Bucket，使用 tencent-cdn 进行加速域名配置。不同的底层 Component 也可以被上层的 Component 组合在一起，实现一个超级 Component，比如 tecent-next、tecent-egg 等。
  - Plugin 是管理普通云函数的工具，它可以很轻松的部署函数 / 删除函数 / 触发函数 / 查看函数信息 / 查看函数日志 / 回滚函数 / 查看函数数据等。相比于 Component 它缺少了一些高级特性，但是 Component 在函数的管理上，只有部署和移除这两个简单的功能

_源码解读在代码块的下方_

首先贴一下部署的配置文件 serverless.yml 内容

```

```

serverless-tencent-scf 是腾讯提供的云函数部署 plugin，我们进入其中看看它做了什么

```
class Tencent extends Plugin {
  constructor(serverless, options) {
    super(serverless, options);
    this.formulaService();
    this.serverless.pluginManager.addPlugin(Provider);
    for (const P of [GetConfig, Deploy, Invoke, Logs, Remove, InitCAM]) {
      this.serverless.pluginManager.addPlugin(P);
    }
  }
  /**
   * 标准化/兼容化 处理配置文件
   */
  formulaService() {
    // provider
    this.formulaFunctionCompibility(this.serverless.service.provider);

    // function
    for (const funcName of Object.keys(this.serverless.service.functions)) {
      const func = this.serverless.service.functions[funcName];
      this.formulaFunction(func);
    }
  }
  ...
}
```

首先进入视野的是一个 Tencent 类的构造函数，在忽略 formulaService 的情况下，可以发现就是向 serverless 实例中不断添加 plugin，按照添加顺序我们一个个的对它们进行拆解
顺序依次是 [ Provider, GetConfig, Deploy, Invoke, Logs, Remove, InitCAM ]

```
export default class TencentProvider extends Plugin {
  constructor(a, b) {
    super(a, b);
    this.serverless.setProvider(PROVIDER_NAME, this);
  }
  credentialConfig = parseCredentialFile(
    untildify(
      this.serverless.service.provider.credentials ||
        `~/.tccli/default.credential`
    )
  );
  api = new API(
    {
      appId: this.credentialConfig.appId,
      secretId: this.credentialConfig.secretId,
      secretKey: this.credentialConfig.secretKey,
      region: this.serverless.service.provider.region,
      proxy:
        process.env.proxy ||
        process.env.HTTP_PROXY ||
        process.env.http_proxy ||
        process.env.HTTPS_PROXY ||
        process.env.https_proxy
    },
    this
  );
  static getProviderName() {
    return PROVIDER_NAME;
  }
  get provider() {
    return this;
  }
}
```

- setProvider 确定服务供应商
- parseCredentialFile 解析本地保存的的云端密钥
- 创建 API 实例，它集成了多种部署作用的 API，会在后面详细介绍它
  Provider 的作用在于与服务供应商建立通信

```
export default class TencentGetConfig extends Plugin {
  commands = {
    tencent: {
      usage: `腾讯云相关指令`,
      commands: {
        getconfig: {
          usage: `(私有指令)获取项目配置`,
          lifecycleEvents: ["getconfig"]
        }
      }
    }
  };
  hooks = {
    "tencent:getconfig:getconfig": async () => {
      this.json({
        success: true,
        data: this.purifyServerlessConfig()
      });
    }
  };
  /**
   * 纯化serverless配置，使它可以安全的序列化，供vscode插件使用
   */
  purifyServerlessConfig() {
    const config = this.serverless.service;
    return {
      name: config.service,
      provider: config.provider,
      functions: config.functions
    };
  }
}
```

发现类上定义了两个 field，分别是 commands 与 hooks。commands 描述了总共都有什么钩子，hooks 描述了每个钩子分别是什么，以及它的 before 与 after 阶段。[点击这里查看它们的详细解释](https://www.serverless.com/framework/docs/providers/aws/guide/plugins/)。getconfig 这个钩子的作用就是提取出 name、provider、functions 这三个配置


```
export default class TencentDeploy extends Plugin {
  ...
  hooks = {
    "deploy:deploy": this.deployJob,
    "deploy:function:packageFunction": () =>
      this.serverless.pluginManager.spawn("package:function"),
    "deploy:function:deploy": this.deployJob
  };
}
```
Deploy Plugin 的 hooks 定义如上，


```
async doDeploy() {
  // 判断是否已经有函数
  const functions = await this.cacheGetAllFunctions();
  const map = new Map<string, Function>();
  for (const f of functions) {
    map.set(f.FunctionName, f);
  }
  // 发布函数
  const tasks = this.getNeedDeployFunctions().map(
    async f =>
      // 这里可考虑进行并发限制 TODO
      await this.deployFunction(f, map.get(f.name))
  );
  await Promise.all(tasks);
}
```
