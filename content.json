{"pages":[{"title":"tags","text":"前端开发 光学","link":"/tags/index.html"}],"posts":[{"title":"OAuth 2.0 认证原理与实践","text":"本文以 Github 为例，通过具体实践来详细描述 OAuth 2.0 认证的原理与流程 比如 CSDN 在登录的时候，用户可以选择 QQ、微信、GitHub 登录等，本文以 Github 为例，通过具体实践来详细描述 OAuth 2.0 认证的原理与流程 认证流程大致可分为一个前置和三个后置步骤 前置步骤 A. 网站在 Github 注册授权应用 后置步骤(认证流程) B. 用户通知 Github 允许将自己的有限信息透露给该网站，网站获得授权码 C. 网站通过授权码获得 access_token D. 网站通过 access_token 获得用户 Github 端的信息 下面依次介绍 A、B、C、D 四个步骤步骤 A在 Github developers 点击 New OAuth App 按钮注册一个 OAuth 应用Authorization callback URL 这一项是授权后重定向的地址，步骤 B 会介绍它注册应用后会生成 Client ID 与 Client Secret, 它们分别用在 B 与 C 步中 步骤 B用户选择了使用 Github 登录后，会跳转到 https://github.com/login/oauth/authorize ，url query 如下 client_id 即 A 步骤中获得的 Client ID redirect_uri 即授权后重定向的页面，它需要是 A 步骤中 Authorization callback URL 的子域名 state 随机生成的字符串，防御 CSRF 攻击，步骤 C 中会介绍它在用户授权了之后，页面会重定向到 _redirect_uri_，同时 url query 上会自动带上 Github 提供的授权码 code 步骤 C此时可以通过 GET 请求访问 https://github.com/login/oauth/access_token 来获得 access_token, Github 官方文档对于这步的介绍很容易误导人 client_id 与 client_secret 即步骤 A 中的 Client Secret, code 即步骤 B 中提供的授权码，state 即步骤 B 中的，两个 state 需要一样，因为步骤 B 中获得的 code 与授权用户是无关的，所以缺少 state 的情况下可能被攻击者利用已获得的授权码来进行 CSRF 攻击 这一步应该在服务端进行，因为要传输 _Client Secret_，缺少服务器的情况下可以考虑使用简单模式 即使想在客户端直接请求也做不到，因为该接口不支持 CORS 协议，所以 POST 请求肯定是无法用的。尝试 使用 GET 请求发现能返回 access_token 但是返回的数据格式为 application/x-www-form-urlencoded 所以也无法使用 JSONP(必须是 “application/javascript” 相关的类型 script 脚本才能执行网络请求否则只会当成代码块) code 等数据需要作为 url query 而不是在请求体中发送 Github 常年被墙，所以对于安全性要求不高应用推荐使用 https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token 进行转发，具体用法可以点击这里，即使国内网络也能正常请求 步骤 D通过 GET https://api.github.com/user?access_token 即可获取用户授权的有限信息","link":"/2020/06/14/OAuth%202.0%20%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"title":"Hexo Serverless 腾讯云部署原理分析","text":"本文从源码的角度分析 hexo 项目在 serverless 部署过程中 component 组件起到的作用 部署流程可以参考 https://cloud.tencent.com/document/product/1154/40217 ，本文着重于分析部署过程中 component 起到的作用首先贴一下部署的配置文件 serverless.yml 内容 myWebsite: component: '@serverless/tencent-website' name: &quot;blog&quot; inputs: code: src: ./public index: index.html region: ap-guangzhou bucketName: blog protocol: https 在命令行敲入 serverless 开始部署后，会执行 component 组件对应的 default 方法来接管部署流程，进入 @serverless/tencent-website 看看它做了什么，源码解读在代码块的下方 const auth = new tencentAuth()this.context.credentials.tencent = await auth.doAuth(this.context.credentials.tencent, { client: 'tencent-website', remark: inputs.fromClientRemark, project: this.context.instance ? this.context.instance.id : undefined, action: 'default'}) 如果本地没有 .env 文件，那么会尝试使用扫描二维码登录 const websiteBucket = await this.load('@serverless/tencent-cos', 'websiteBucket')await websiteBucket({ bucket: inputs.bucketName, region: inputs.region, acl: { permissions: 'public-read', grantRead: '', grantWrite: '', grantFullControl: '' }, fromClientRemark: inputs.fromClientRemark || 'tencent-website'}) 尝试创建 Bucket, 即配置中的 bucketName 字段，代表该应用在云端的仓库名称，Bucket 存储在腾讯云对象存储 COS 上 const tencentConf = this.context.credentials.tencentconst cos = new COS({ SecretId: tencentConf.SecretId, SecretKey: tencentConf.SecretKey, TmpSecretId: tencentConf.SecretId, TmpSecretKey: tencentConf.SecretKey, XCosSecurityToken: tencentConf.token, ExpiredTime: tencentConf.timestamp, UserAgent: 'ServerlessComponent'}) tencentConf 是上面获取的云端用户信息COS 是 npm 包 cos-nodejs-sdk-v5，在这里作用是对 Bucket 仓库进行配置 await configureBucketForHosting( cos, inputs.bucketName, this.context.credentials.tencent.AppId, inputs.region, inputs.code.index, inputs.code.error, inputs.cors || null, inputs.protocol) 首先设置 Bucket 的跨域资源共享权限 然后设置 Bucket 的静态网站配置信息, 注意此时应用并没有上传 this.context.status('Uploading')const dirToUploadPath = inputs.code.src || inputs.code.rootthis.context.debug( `Uploading website files from ${dirToUploadPath} to bucket ${inputs.bucketName}.`)const uploadDict = { fromClientRemark: inputs.fromClientRemark || 'tencent-website'}if (fs.lstatSync(dirToUploadPath).isDirectory()) { uploadDict.dir = dirToUploadPath} else { uploadDict.file = dirToUploadPath}await websiteBucket.upload(uploadDict) dirToUploadPath 是配置中的 inputs.code.src，代表要上传的文件夹调用 websiteBucket.upload 方法将 dirToUploadPath 中的内容上传，下面看下这个 upload 方法 this.context.debug(`Uploading directory ${inputs.dir} to bucket ${bucket}`)// upload directory contentsconst options = { keyPrefix: inputs.keyPrefix }const items = await new Promise((resolve, reject) =&gt; { try { resolve(klawSync(inputs.dir)) } catch (error) { reject(error) }})let handlerlet keyconst uploadItems = []items.forEach((item) =&gt; { if (item.stats.isDirectory()) { return } key = path.relative(inputs.dir, item.path) if (options.keyPrefix) { key = path.posix.join(options.keyPrefix, key) } // convert backslashes to forward slashes on windows if (path.sep === '\\\\') { key = key.replace(/\\\\/g, '/') } const itemParams = { Bucket: bucket, Region: region, Key: key, Body: fs.createReadStream(item.path) } handler = util.promisify(clients.putObject.bind(clients)) uploadItems.push(handler(itemParams))})await Promise.all(uploadItems) 使用的是自身创建的 cos-nodejs-sdk-v5 实例，用它的 putObject 方法并发上传目标目录下的所有文件，这一步耗时最长cos-nodejs-sdk-v5 是对腾讯云对象存储 COS XML API 的封装，此时 public 目录内的文件已经上传到 Bucket let tencentCdnlet tencentCdnOutputlet cdnInputsthis.state.host = new Array()this.state.hostName = new Array()for (let i = 0; i &lt; inputs.hosts.length; i++) { cdnInputs = inputs.hosts[i] cdnInputs.hostType = 'cos' cdnInputs.serviceType = 'web' cdnInputs.fwdHost = cosOriginAdd cdnInputs.origin = cosOriginAdd tencentCdn = await this.load( '@serverless/tencent-cdn', inputs.hosts[i].host.replace('.', '_') ) cdnInputs.fromClientRemark = inputs.fromClientRemark || 'tencent-website' tencentCdnOutput = await tencentCdn(cdnInputs) const protocol = tencentCdnOutput.https ? 'https' : 'http' this.state.host.push( protocol + '://' + tencentCdnOutput.host + ' (CNAME: ' + tencentCdnOutput.cname + 'ï¼‰' ) this.state.hostName.push(inputs.hosts[i].host.replace('.', '_'))} 只有 yml 中配置了 host，才会进入上面的代码逻辑中，使用 @serverless/tencent-cdn 来配置加速域名。实际是调用 AddCdnHost 来增加域名 到此部署的流程已经走完，可以在 https://console.cloud.tencent.com/cos5/bucket 上查看已经部署上去的应用 总结@serverless/tencent-website 与云函数无关，它只是将代码上传到 Bucket，但是这个对于静态网站来说已经足够了，访问 Bucket 上的 index.html 文件即可浏览网站。如果想要了解云函数，可阅读","link":"/2020/06/16/hexo-serverless%20%E8%85%BE%E8%AE%AF%E4%BA%91%E9%83%A8%E7%BD%B2%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"title":"eggjs serverless 腾讯云部署原理分析","text":"本文从源码的角度分析 eggjs 项目在 serverless 部署过程中 component 组件起到的作用 首先贴一下部署的配置文件 serverless.yml 内容 name: knowledge-backEndknowledge-api: component: '@serverless/tencent-egg' inputs: runtime: Nodejs10.15 code: ./ exclude: ['./node_modules/**', './test/**', './.github/**', &quot;./deploy-layer/**&quot;] functionName: knowledge-api functionConf: timeout: 120 apigatewayConf: apigatewayConf: true protocols: - https 首先解释下除了 component 外其他的字段 exclude：配合腾讯云层管理，deploy-layer 即为压缩后的 node_modules 然后进入 @serverless/tencent-egg 中看看它做了什么，代码很短，直接全部贴出来 class TencentComponent extends Component { async default(inputs = {}) { inputs.include = ensureIterable(inputs.include, { default: [], ensureItem: ensureString }) inputs.runtime = ensureString(inputs.runtime, { default: DEFAULTS.runtime }) const cachePath = path.join( os.homedir(), `.serverless/cache/tencent-${DEFAULTS.framework}`, pkg.version, 'serverless-handler.js' ) if (!fs.existsSync(cachePath)) { this.context.debug('Generating serverless handler...') await bundler({ input: path.join(__dirname, 'shims/handler.js'), output: cachePath }) this.context.debug('Generated serverless handler successfully.') } inputs.handler = `${path.basename(cachePath, '.js')}.handler` inputs.include.push(cachePath) const Framework = await this.load('@serverless/tencent-framework') const framworkOutpus = await Framework({ ...inputs, ...{ framework: DEFAULTS.framework } }) this.state = framworkOutpus await this.save() return framworkOutpus } async remove(inputs = {}) { const Framework = await this.load('@serverless/tencent-framework') await Framework.remove(inputs) this.state = {} await this.save() return {} }} 如果本地找不到 serverless-handler.js，那么打包 shims/handler.js，它会作为云函数的入口文件 tencent-framework: 腾讯云的很官方提供的 serverless component 都是基于这个包做的封装，它提供部署云函数的能力 本文着重分析入口文件 shims/handler.js const path = require('path')const fs = require('fs')const { createServer, proxy } = require('tencent-serverless-http')module.exports.handler = async (event, context) =&gt; { const userSls = path.join(__dirname, 'sls.js') let app if (fs.existsSync(userSls)) { // eslint-disable-next-line console.log('Using user custom sls.js') app = require(userSls) } else { app = require('./sls') } context.callbackWaitsForEmptyEventLoop = app.callbackWaitsForEmptyEventLoop === true ? true : false if (!global.server) { global.server = createServer(app.callback(), null, app.binaryTypes || []) } return proxy(global.server, event, context, 'PROMISE').promise} 众所周知，云函数是冷启动的。所以为了让 eggjs 在云端可以处理 http 请求，需要先启动一个 eggjs 应用。然后将 serverless 请求对象 event 封装为 eggjs 可以识别的 req 对象。这些都是由 tencent-serverless-http 这个包完成的，我们看看 createServer 做了什么。sls.js 文件用来创建 eggjs 实例，逻辑比较简单在此不做分析 function createServer (requestListener, serverListenCallback, binaryTypes) { const server = http.createServer(requestListener) server._socketPathSuffix = getRandomString() server._binaryTypes = binaryTypes ? binaryTypes.slice() : [] server.on('listening', () =&gt; { server._isListening = true if (serverListenCallback) serverListenCallback() }) server.on('close', () =&gt; { server._isListening = false }) .on('error', (error) =&gt; { /* istanbul ignore else */ if (error.code === 'EADDRINUSE') { console.warn(`WARNING: Attempting to listen on socket ${getSocketPath(server._socketPathSuffix)}, but it is already in use. This is likely as a result of a previous invocation error or timeout. Check the logs for the invocation(s) immediately prior to this for root cause, and consider increasing the timeout and/or cpu/memory allocation if this is purely as a result of a timeout. tencent-serverless-http will restart the Node.js server listening on a new port and continue with this request.`) server._socketPathSuffix = getRandomString() return server.close(() =&gt; startServer(server)) } else { console.log('ERROR: server error') console.error(error) } }) return server} createServer 创建了一个 httpServer 实例, 然后我们看 proxy 方法 function proxy (server, event, context, resolutionMode, callback) { // 省略 .... return { promise: new Promise((resolve, reject) =&gt; { const promise = { resolve, reject } const resolver = makeResolver({ context, callback, promise, resolutionMode }) if (server._isListening) { forwardRequestToNodeServer(server, event, context, resolver) } else { startServer(server) .on('listening', () =&gt; forwardRequestToNodeServer(server, event, context, resolver)) } }) }}function startServer (server) { return server.listen(getSocketPath(server._socketPathSuffix))}function getSocketPath (socketPathSuffix) { /* istanbul ignore if */ /* only running tests on Linux; Window support is for local dev only */ if (/^win/.test(process.platform)) { const path = require('path') return path.join('\\\\\\\\?\\\\pipe', process.cwd(), `server-${socketPathSuffix}`) } else { return `/tmp/server-${socketPathSuffix}.sock` }} 因为只是云端本机通信，所以 startServer 使用的是 unix socket 通信，它的性能优于 internet socket然后我们看 forwardRequestToNodeServer，serverless 转发来的请求会由它进行处理 function forwardRequestToNodeServer (server, event, context, resolver) { try { const requestOptions = mapApiGatewayEventToHttpRequest(event, context, getSocketPath(server._socketPathSuffix)) const req = http.request(requestOptions, (response) =&gt; forwardResponseToApiGateway(server, response, resolver)) if (event.body) { const body = getEventBody(event) req.write(body) } req.on('error', (error) =&gt; forwardConnectionErrorResponseToApiGateway(error, resolver)) .end() } catch (error) { forwardLibraryErrorResponseToApiGateway(error, resolver) return server }}function mapApiGatewayEventToHttpRequest (event, context, socketPath) { const headers = Object.assign({}, event.headers) // NOTE: API Gateway is not setting Content-Length header on requests even when they have a body if (event.body &amp;&amp; !headers['Content-Length']) { const body = getEventBody(event) headers['Content-Length'] = Buffer.byteLength(body) } const clonedEventWithoutBody = clone(event) delete clonedEventWithoutBody.body return { method: event.httpMethod, path: getPathWithQueryStringParams(event), headers, socketPath }} mapApiGatewayEventToHttpRequest 会将 serverless event 对象封装为 nodejs http 请求对象到此，入口函数已经分析完毕 总结本文介绍了 eggjs 应用在云端的部署原理，其他的 nodejs 应用在云端部署的逻辑也大致一样","link":"/2020/07/15/eggjs-serverless-%E8%85%BE%E8%AE%AF%E4%BA%91%E9%83%A8%E7%BD%B2%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"title":"TypeScript高级应用。与最佳实践？","text":"本文结合实际场景来讲解 TS 高级类型在实际场景中的使用 本文讲解 TS 高级类型在实际场景中的使用 TS 类型系统可分为基本类型与复合类型 基本类型基本类型，也可以理解为原子类型。包括 number、boolean、string、null、undefined、function、array、字面量（true，false，1，2，‘a’）等。它们无法再细分。 复合类型TypeScript 的复合类型可以分为两类：set 和 map。set 是指一个无序的、无重复元素的集合。而 map 则和 JS 中的对象一样，是一些没有重复键的键值对。 // settype Size = 'small' | 'default' | 'big' | 'large';// mapinterface IA { a: string b: number} TS 中还支持一些类型关键字，比如 keyof, typeof, in, extends, infer 等 extends 继承类型，支持条件判断，e.g type test&lt;T&gt; = T extends someType ? T : never typeOf 获得一个 JS 变量的推论类型 keyof 获得一个 TS 类型的所有 key 值 in 遍历可枚举 TS 类型，e.g type Obj = { [p in Keys]: any } infer 必须在 extends 条件语句中，表明待推断的类型变量\b TS 中还支持一些操作符，比如 T[K] 等 T[K] 索引访问操作符，type test = { a: string, b: number }; test[a] =&gt; string TS 高级应用通常会借助复合类型与关键字与操作符的配合, 搞清楚它们的用法是熟练使用 TS 高级应用的前提实战解析 例1 前端需要洗从服务端获取的列表数据，只取前端需要的字段type dataObj = { name: string url: string price: number location: string}// 获得子类型type FilterKeys&lt;T, K extends keyof T&gt; = { [Key in K]: T[Key] }function getData&lt;T, K extends keyof T&gt;(list: Array&lt;T&gt;, keys: Array&lt;K&gt;): FilterKeys&lt;T, K&gt;[] { const result = [] list.forEach(item =&gt; { const obj: any = {} keys.forEach((key: any) =&gt; (obj[key] = item[key])) result.push(obj) }) return result}const list: dataObj[] = [{ name: &quot;name&quot;, url: &quot;url&quot;, price: 22, location: &quot;location&quot; }]// 取 name url 字段const result = getData&lt;dataObj, &quot;name&quot; | &quot;url&quot;&gt;(list, [&quot;name&quot;, &quot;url&quot;]) FilterKeys 也可以用 TS 内置的类型 Pick 替代 getData 方法的类型标注通过泛型 + extends + keyof + in + 索引访问操作符来完成 例2 获得 Promise 返回值的类型// somePackageinterface Person { title: string avatar: string}export const somefunc = async function() { return { title: &quot;22&quot;, avatar: &quot;http://&quot; } as Person}// file2.jsimport { somefunc } from 'somePackage'type PromiseType&lt;T&gt; = (args: any[]) =&gt; Promise&lt;T&gt;;// infer 等于一个变量，在类型推导的时候才会赋值type UnPromisify&lt;T&gt; = T extends PromiseType&lt;infer U&gt; ? U : never;type UnArray&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : never;async function test() { const resp = await somefunc() type resp_type = UnArray&lt;UnPromisify&lt;typeof somefunc&gt;&gt; resp = resp.map(item =&gt; ({ ...item, name: &quot;name&quot; })) return resp as (Array&lt;resp_obj_type &amp; { name: string }&gt;)} somePackage 输出了 async 函数但是没有输出返回值的类型test 的返回值不加类型标注的话，TS 无法知道又添加了 name 字段UnPromisify 与 UnArray 通过泛型 + never + infer + typeof 来实现 例3 已知 React 组件的 props 类型，获取类型中所有 value 的 type == function 的子类型interface someProps { prop1: string prop2: number prop3: () =&gt; void prop4: (e: someEvent) =&gt; void }type getConditionType&lt;T, Condition&gt; = Pick&lt;T, { [K in keyof T]: T[K] extends Condition ? K : never}[keyof T]&gt;// someProps 只包含 function 类型的子类型type someProps_function_type = getConditionType&lt;someProps, Function&gt; 利用了索引访问操作符会忽略 never 类型的特性，e.g type A { a: number; b: 'b'; c: never };type B = keyof A; type C = A[B];// 等于 number | &quot;b&quot; | never, 联合类型会忽略 nevertype C =&gt; number | &quot;b&quot;, 这里 never 去除了 getConditionType 通过泛型 + never + keyof + extends + Pick + 联合类型忽略 never 的特性实现 例4 已知 React 组件的 props 类型 T，获得去除成员 K 的子类型interface someProps { prop1: string prop2: number prop3: () =&gt; void prop4: (e: someEvent) =&gt; void }type Exclude&lt;T, U&gt; = T extends U ? never : T;type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;// 只包含 prop2 与 prop4 成员type test = Omit&lt;someProps, &quot;prop1&quot; | &quot;prop3&quot;&gt; Exclude 和 Omit 已被 TS 原生支持Exclude 里 T 与 U 均为联合类型，T extends U 的机制是 T 的每个子类型与 U 进行比较Omit 通过 extends + 联合类型忽略 never + keyof另外一种实现方法如下: type Diff&lt;T extends keyof any, U extends keyof any&gt; = ({ [P in T]: P } &amp; { [P in U]: never })[T];type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Diff&lt;keyof T, K&gt;&gt;; keyof any == string | number | symbol，只用 K extends string TS 会报错，因为不能确定 keyof T 得到的联合类型中全部是 string还是 TS 内置的 Omit 实现更为优雅 总结熟练掌握高级类型的使用，是通向 TS 高级应用的最优途径","link":"/2020/07/10/TypeScript%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E3%80%82%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9F/"},{"title":"解决 install 时 yarn 和 npm 混用的问题","text":"本文提出一种解决 install 时 yarn 与 npm 混用造成依赖版本错误的方案 yarn 与 npm 混用的问题yarn 与 npm 是两个包管理工具，但是由于它们的 lock 文件不共享，所以如果不小心在 yarn 项目中使用了 npm install，那么整个依赖树的版本就会错乱掉。只能删除 node_modules 重新安装 如何解决npm 和 yarn 提供了一个 preinstall 的钩子，该钩子在 install 之前执行所以可以在钩子中判断当前执行的是否是期望的 npm 或 yarn由于不同操作系统下判断代码不一致，所以封装一个 npm 包是最佳选择 代码分析const os = require(&quot;os&quot;)const exec = require(&quot;child_process&quot;).exec;const program = require('commander')program .version('0.0.1') .option('-f, --force &lt;n&gt;', 'force npm or yarn') .parse(process.argv)const forceTarget = ['npm', 'yarn'].indexOf(program.force) !== - 1 ? program.force : &quot;yarn&quot;const reg = forceTarget == &quot;npm&quot; ? `\\&quot;npm-cli\\&quot;` : `\\&quot;yarn.js\\&quot;`const command = os.platform() == 'win32' ? `echo \\&quot;%npm_execpath%\\&quot; | findstr ${reg} || (echo fail)` : `echo \\&quot;$npm_execpath\\&quot; | grep -q ${reg} || (echo fail)`function check() { return new Promise((r, j) =&gt; { exec(command, function ( err, stdot, stderr ) { if (stdot.indexOf(&quot;fail&quot;) !== -1) { console.warn(`-------------------⚠️ Use ${forceTarget} not ${['npm', 'yarn'].filter(item =&gt; item !== forceTarget)[0]}! ⚠️-------------------`); process.exit(1); } r(); }); });}async function main() { await check();}main(); win 和 linux 分别使用 %npm_execpath% $npm_execpath 获取正在执行的包管理工具，分别使用 findstr 和 grep 判断是否是当前期望的 如果不符合当前期望，执行 process.exit(1) 强行退出当前 nodejs 进程 使用 “preinstall”: “force-yarn-or-npm –force yarn” 在 package.json 中注册钩子，通过 force 参数控制当前需要强制哪个包管理工具","link":"/2020/07/16/%E8%A7%A3%E5%86%B3-install-%E6%97%B6-yarn-%E5%92%8C-npm-%E6%B7%B7%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"SCF Serverless 腾讯云部署原理分析","text":"本文以 plugin serverless-tencent-scf 为例，从源码角度分析云函数部署流程 在 文中描述的是 serverless component 的部署原理，本文阐述的是 serverless plugin 的工作原理，下面用简单的篇幅来说明这两者的区别。 什么是 Serverless Component 相同之处。这两者均是部署云函数的不同方案 不同之处 Component 是云产品的工具，云产品可以理解为高级的云函数。通过配置 Yaml 可以组合使用 Component，比如使用 tencent-cos 部署 Bucket，使用 tencent-cdn 进行加速域名配置。不同的底层 Component 也可以被上层的 Component 组合在一起，实现一个超级 Component，比如 tecent-next、tecent-egg 等。 Plugin 是管理普通云函数的工具，它可以很轻松的部署函数 / 删除函数 / 触发函数 / 查看函数信息 / 查看函数日志 / 回滚函数 / 查看函数数据等。相比于 Component 它缺少了一些高级特性，但是 Component 在函数的管理上，只有部署和移除这两个简单的功能 源码解读在代码块的下方 首先贴一下部署的配置文件 serverless.yml 内容 service: image-hostingprovider: name: tencent region: ap-guangzhou runtime: Nodejs8.9 stage: dev credentials: ~/.tencentcloud/credentials.iniplugins: - serverless-tencent-scfpackage: exclude: - ./** include: - index.js - util.js - config.jsfunctions: hello: handler: index.main_handler description: image upload and get function memorySize: 128 timeout: 3 serverless-tencent-scf 是腾讯提供的云函数部署 plugin，我们进入其中看看它做了什么 class Tencent extends Plugin { constructor(serverless, options) { super(serverless, options); this.formulaService(); this.serverless.pluginManager.addPlugin(Provider); for (const P of [GetConfig, Deploy, Invoke, Logs, Remove, InitCAM]) { this.serverless.pluginManager.addPlugin(P); } } /** * 标准化/兼容化 处理配置文件 */ formulaService() { // provider this.formulaFunctionCompibility(this.serverless.service.provider); // function for (const funcName of Object.keys(this.serverless.service.functions)) { const func = this.serverless.service.functions[funcName]; this.formulaFunction(func); } } ...} 首先进入视野的是一个 Tencent 类的构造函数，在忽略 formulaService 的情况下，可以发现就是向 serverless 实例中不断添加 pluginplguin 类上会定义两个 field，分别是 commands 与 hooks。commands 描述了总共都有什么钩子，hooks 描述了每个钩子分别是什么，以及它的 before 与 after 阶段。点击这里查看它们的详细解释。plugin 会为 serverless 实例添加 hooks，对应命令行输入的指令。比如 serverless deploy 会执行 Deploy 注入的 hooks按照添加顺序我们一个个的对它们进行拆解，顺序依次是 [ Provider, GetConfig, Deploy, Invoke, Logs, Remove, InitCAM ] Provider，它没有提供 hooks，每次均会执行export default class TencentProvider extends Plugin { constructor(a, b) { super(a, b); this.serverless.setProvider(PROVIDER_NAME, this); } credentialConfig = parseCredentialFile( untildify( this.serverless.service.provider.credentials || `~/.tccli/default.credential` ) ); api = new API( { appId: this.credentialConfig.appId, secretId: this.credentialConfig.secretId, secretKey: this.credentialConfig.secretKey, region: this.serverless.service.provider.region, proxy: process.env.proxy || process.env.HTTP_PROXY || process.env.http_proxy || process.env.HTTPS_PROXY || process.env.https_proxy }, this ); static getProviderName() { return PROVIDER_NAME; } get provider() { return this; }} setProvider 确定服务供应商 parseCredentialFile 解析本地保存的的云端密钥 创建 API 实例，它集成了多种部署作用的 API，会在后面详细介绍它Provider 的作用在于与服务供应商建立通信 GetConfig。serverless tecent getconfig 命令会执行该 Plugin 注册的 hooksexport default class TencentGetConfig extends Plugin { commands = { tencent: { usage: `腾讯云相关指令`, commands: { getconfig: { usage: `(私有指令)获取项目配置`, lifecycleEvents: [&quot;getconfig&quot;] } } } }; hooks = { &quot;tencent:getconfig:getconfig&quot;: async () =&gt; { this.json({ success: true, data: this.purifyServerlessConfig() }); } }; /** * 纯化serverless配置，使它可以安全的序列化，供vscode插件使用 */ purifyServerlessConfig() { const config = this.serverless.service; return { name: config.service, provider: config.provider, functions: config.functions }; }} getconfig 这个钩子的作用就是提取出 name、provider、functions 这三个配置 Deploy。serverless deploy 会执行该 plugin 注册的钩子export default class TencentDeploy extends Plugin { ... hooks = { &quot;deploy:deploy&quot;: this.deployJob, &quot;deploy:function:packageFunction&quot;: () =&gt; this.serverless.pluginManager.spawn(&quot;package:function&quot;), &quot;deploy:function:deploy&quot;: this.deployJob };} deployJob 会进入 doDeploy 来进行部署，下面开始分析 doDeploy async doDeploy() { // 判断是否已经有函数 const functions = await this.cacheGetAllFunctions(); const map = new Map&lt;string, Function&gt;(); for (const f of functions) { map.set(f.FunctionName, f); } // 发布函数 const tasks = this.getNeedDeployFunctions().map( async f =&gt; // 这里可考虑进行并发限制 TODO await this.deployFunction(f, map.get(f.name)) ); await Promise.all(tasks);}async getAllFunctions() { const maxPageSize = 100; let list: Function[] = []; let total = 0; do { const { Functions, TotalCount } = await this.ListFunctions( list.length, maxPageSize ); total = TotalCount; list = list.concat(Functions); } while (list.length &lt; total); return list;}ListFunctions(offset: number, limit: number) { return this.provider.api.scf.ListFunctions({ Offset: offset, Limit: limit });}getNeedDeployFunctions() { const functions = this.serverless.service.functions; return Object.keys(functions) .filter(name =&gt; { const specifiedFunction = this.options[&quot;function&quot;]; return !specifiedFunction || specifiedFunction === name; }) .map&lt;ServiceFunction&gt;(name =&gt; { return functions[name]; });}async deployFunction(f: ServiceFunction, r: Function) { if (r) { // 已经有函数了 return this.deployExistsFunction(f); } // 没有，需要新建 return this.deployNewFunction(f);}async deployNewFunction(f: ServiceFunction) { this.log(`开始创建函数 ${f.name}`); await this.provider.api.scf.CreateFunction({ FunctionName: f.name, Handler: f.handler, MemorySize: f.memorySize, Description: f.description, Timeout: f.timeout, Environment: parseEnvironment(f.environment), Runtime: this.serverless.service.provider.runtime, VpcConfig: parseVpcConfig(f.vpc), Code: await this.getServiceCode(f) }); this.log(`创建函数 ${f.name} 完成`); await this.deployTriggers(f, []);}async getServiceCode(func: ServiceFunction): Promise&lt;Code&gt; { const filePath = func.package.artifact || this.serverless.service.package.artifact; // 当文件小时，直接提交 const size = statSync(filePath).size; if (size &lt; MAX_DIRECTLY_POST_PACKAGE_SIZE) { return { ZipFile: await fileToBase64(filePath) }; } // 其它情况通过cos上传 this.debug( `函数 ${ func.name } 发布包超过 ${MAX_DIRECTLY_POST_PACKAGE_SIZE} 字节，使用cos方式上传` ); await this.provider.api.cam.assureScfPolicy(SCF_CAM_POLICY_COS); const result = await this.provider.api.scf.upload(filePath, func); return { // 此处Bucket不传appId CosBucketName: result.Bucket.replace(/\\-\\d+$/, &quot;&quot;), // 此处需要是路径，以 / 起始 CosObjectName: &quot;/&quot; + result.Key, CosBucketRegion: this.serverless.service.provider.region };} 首先看 cacheGetAllFunctions，它会进入 getAllFunctions 调用 api ListFunctions 获得已经部署的所有云函数 然后通过 getNeedDeployFunctions 获得 yaml 中 functions 配置，用 deployFunction 处理每个要部署的云函数 deployFunction 针对已经部署过的云函数走 deployExistsFunction 逻辑，新增的走 deployNewFunction 逻辑 deployNewFunction 首先通过 getServiceCode 将云函数项目先上传到 Bucket 然后通过 CreateFunction 创建云函数 进入 getServiceCode 看看它做了什么 filePath 变量指的是压缩包文件的路径，在上传前 首先通过 assureScfPolicy 来进行角色鉴权，该角色如果已经被授权可以部署云函数 然后重点来了，使用 API 实例上的 upload 方法来将云函数项目先上传到 Bucket。下面来看下 upload 方法 // 换存用户自己的cos，如果文件无变更，则返回falseasync upload(zipFile: string, func: ServiceFunction) { if (!this.options.appId) { throw new Error( `没有配置tencent_app_id，无法进行大于 ${MAX_DIRECTLY_POST_PACKAGE_SIZE}Byte 的包文件上传` ); } const commonOptions = { Bucket: this.bucketName, Region: this.options.region, Key: func.name + &quot;.zip&quot; }; // 确保bucket存在 await this.cacheAssureBucketExists(); // 准备上传 // 先判断文件有没有存在，如果存在并且hash一致，跳过 this.provider.debug(`计算发布文件hash值`); const hash = await hashFile(zipFile); let headResult; try { this.provider.debug(`检查函数${func.name}在cos的历史发布文件`); headResult = await this.cosHeadObject({ ...commonOptions }); } catch (e) { if (e.statusCode !== 404) { throw new Error( `无法访问cos，请使用主帐号给本帐号关联相关CAM策略（例如：QcloudCOSFullAccess） ${JSON.stringify( e )}` ); } headResult = e; } if (hash !== headResult.headers[hashKey]) { // 上传 this.provider.debug(`上传函数${func.name}发布文件到cos`); await this.cosSliceUploadFile({ ...commonOptions, FilePath: zipFile, [hashKey]: hash }); } else { this.provider.debug(`函数${func.name}在cos的发布文件不需要更新`); } return commonOptions;} 首先调用 assureBucketExists 检查 Bucket 是否存在，如果不存在那么创建新的 Bucket。 然后使用 hashFile 来计算打包文件的 hash 值与之前的进行对比，存在改变则上传到 Bucket upload 结束后，进入 CreateFunction 创建完云函数后，再定义它的触发器。下面看 deployTriggers 做了什么 async deployTriggers(f: ServiceFunction, triggers: Trigger[]) { this.log(`开始更新函数 ${f.name} 触发器`); const existsTriggers = new Map&lt;string, TriggerImpl&lt;any&gt;&gt;(); for (const trigger of triggers) { const impl = getTrigger(f, trigger.Type, null, trigger); existsTriggers.set(impl.hash, impl); } // 应该先删再建，避免超额度 const needCreateTriggers: TriggerImpl&lt;any&gt;[] = []; for (const wrap of f.events) { const type = Object.keys(wrap)[0] as TriggerType; const trigger = wrap[type]; const local = getTrigger(f, type as TriggerType, trigger); if (!local) { this.log(`无法识别函数 ${f.name} 触发器类型: ${type}`); continue; } const remote = existsTriggers.get(local.hash); // 不存在的，创建 if (!remote) { needCreateTriggers.push(local); } else { existsTriggers.delete(local.hash); } } // 远端多出的，就是要删除的 for (const [type, remote] of existsTriggers) { this.log( `开始删除函数 ${f.name} 触发器 ${remote.Type}:${remote.TriggerName}` ); await this.provider.api.scf.DeleteTrigger({ FunctionName: f.name, Type: remote.Type, TriggerName: remote.TriggerName, TriggerDesc: remote.TriggerDesc }); await remote.afterDelete(this.provider); this.log( `删除函数 ${f.name} 触发器 ${remote.Type}:${remote.TriggerName} 完成` ); } // 创建 for (const trigger of needCreateTriggers) { const params = { FunctionName: f.name, Type: trigger.Type, TriggerName: trigger.TriggerName, TriggerDesc: trigger.TriggerDescForCreation }; this.log( `开始创建函数 ${f.name} 触发器 ${params.Type}:${params.TriggerName}` ); await trigger.beforeCreate(this.provider); await this.provider.api.scf.CreateTrigger(params); this.log( `创建函数 ${f.name} 触发器 ${params.Type}:${params.TriggerName} 完成` ); } if (!existsTriggers.size &amp;&amp; !needCreateTriggers.length) { this.log(`函数 ${f.name} 触发器无需更新`); } else { this.log(`函数 ${f.name} 触发器更新完成`); }} 根据配置中的 events 字段来配置触发器 Invoke如果执行的是 serverless invoke 命令，那么会进入这里。该钩子逻辑较简单，测试下上面部署的云函数是否运行正常 Log如果执行的是 serverless logs 命令，那么会进入这里。该钩子逻辑较简单，获取函数运行日志 Remove如果执行的是 serverless remove 命令，那么会进入这里。该钩子逻辑较简单，移除某个云函数 InitCam如果执行的是 serverless tencent initcam 命令，那么会进入这里。这样就会初始化角色授权，使得 scf 可以访问其它业务资源（如对象存储、API 网关等） 总结SCF Plugin 通过注入 hooks 来实现云函数工具箱，根据命令行中 serverless 命令传入的参数来启动不同的 hooks 完成部署、移除等操作","link":"/2020/06/23/SCF%20Serverless%20%E8%85%BE%E8%AE%AF%E4%BA%91%E9%83%A8%E7%BD%B2%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"}],"tags":[{"name":"前端开发","slug":"前端开发","link":"/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"前端开发 serverless","slug":"前端开发-serverless","link":"/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-serverless/"}],"categories":[]}